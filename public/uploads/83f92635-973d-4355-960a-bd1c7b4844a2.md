# 알고리즘 공부

## 시간복잡도
 - 입력 크기가 커짐에 따라 알고리즘의 실행 시간이 얼마나 빠르게 증가하는지를 나타내는 지표
 
		 -- 상수시간[O(1)] ex) 배열에서 특정 인덱스 접근
		 -- 로그시간[O(log n)] ex) 이진 탐색 (Binary Search)
		 -- 선형시간[O(n)] ex) 배열 전체 순회 (선형 탐색)
		 -- 선형로그시간[O(nlog n)] ex) 병합 정렬 (Merge Sort), 퀵 정렬 (Quick Sort)
		 -- 이차시간[O(n^2)] ex) 버블 정렬 (Bubble Sort), 삽입 정렬 (Insertion Sort)
		 -- 지수시간[O(2^n)] ex) 브루트 포스 방식의 일부 조합 문제
		 -- 팩토리얼[O(n!)] ex) 순열

## 자료구조

### 선형자료구조

	- Array
	- Linked List : 노드들이 포인터로 연결
	- Stack : 후입선출(LIFO)
	- Queue : 선입선출(FIFO)
	- Heap : 완전 이진트리 기반 자료구조

### 비선형자료구조

	- 트리 : 계층적으로 구조화하여 저장하는 자료구조
	- 그래프 : 정점(vertices)과 그들 사이를 연결하는 간선(Edge)으로 표현된 자료구조
	- B-TREE(데이터베이스 인덱스의 표준) : 데이터를 정렬하여 탐색, 삽입, 삭제 및 순차 접근이 가능하도록 유지하는 트리형 자료구조[BOM에서 많이 사용된다고 알려짐]


## 탐색

	- 선형탐색 : 배열이나 리스트와 같은 데이터 구조에서 특정한 값을 찾는 알고리즘
	- 이진탐색 : 정렬된 배열에서 특정값을 찾는 알고리즘

	- 완전탐색
		- 브루트포스 : 모든 경우의 수 탐색
		- 백트래킹 : 탐색 도중 막히면 그 지점으로 다시 돌아가 경로 탐색
		- 비트마스크 : 모든 경우의 수를 이진수로 표현하고, 비트연산을 통해 결과 획득
		- 순열: 순열을 이용하여 모든 경우의 수 탐색
		- 재귀함수 : 자기자신을 호출하여 모든 가능한 경우의 수 탐색

		- DFS : 깊이 우선
			- BOM에서 활용(전체 구성 요소를 파악)
				- 각 부품의 최하위 레벨을 결정하여 원가 계산 및 MRP(자재 소요 계획)에 활용할 때 사용
				- 특정 완제품을 만드는 데 필요한 모든 원자재 목록을 계층적으로 빠짐없이 파악할 때 효과적

		- BFS : 넓이 우선
			- BOM에서 활용(레벨별로 부품을 파악하거나, 특정 부품이 어느 레벨에 있는지 파악)
				- 3단계 조립 레벨에 있는 모든 부품'을 찾거나, 특정 단계까지만 부품을 전개할 때 사용
				- (BOM 구조가 복잡한 그래프 형태일 경우) 두 부품 사이의 가장 짧은 포함 관계를 찾을 때 유리


## 알고리즘 설계

	- 분할정복(Divide and Conquer): 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
	- 탐욕 알고리즘(Greedy): 최적의 값을 구해야 하는 상황에서 사용되는 근시안적인 방법론으로 ‘각 단계에서 최적이라고 생각되는 것을 선택’ 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘
	- 동적계획법(Dynamic Programming): 주어진 문제를 해결하기 위해 여러개의 하위 문제로 나누어 푼 다음 결합하여 답을 찾는 방법
		- 최적의 구성경로, 최소비용 찾을때

## 정렬

	- 버블정렬: 매번 연속된 두 개의 인덱스 비교, 정한 기준값을 뒤로 넘겨 정렬하는 방식
	- 선택정렬: 배열에서 가장 작은 원소를 찾아 정렬되지 않은 부분의 가장 앞 원소와 교환
	- 삽입정렬: 정렬되지 않은 부분의 원소를 하나씩 꺼내  정렬된 부분의 올바른 위치에 삽입
	- 합병정렬: 리스트를 더 이상 나눌 수 없을때까지 분할한 다음, 분할된 부분 리스트들을 정렬하면서 병합하여 정렬
	- 퀵  정렬: 분할정복 방식, 리스트에서 피벗을 선택하고 피벗을 기준으로 작은원소는 왼쪽, 큰 원소는 오른쪽으로 분할 뒤 재귀적 반복
	- 힙  정렬: 힙 자료구조를 이용한 정렬 알고리즘


## 시간복잡도 표 (Concept vs Time Complexity)

| 카테고리 | 개념 | 시간복잡도 |
|---|---|---|
| 배열(Array) | 인덱스 접근 | `O(1)` |
|  | 탐색 | `O(n)` |
| 연결리스트(Linked List) | 탐색 | `O(n)` |
|  | 삽입/삭제(노드 위치 알고 있을 때) | `O(1)` |
| 스택(Stack) | push/pop | `O(1)` |
| 큐(Queue) | enqueue/dequeue | `O(1)` |
| 힙(Heap) | 삽입/삭제 | `O(log n)` |
| 해시(Hash Table) | 평균 탐색/삽입/삭제 | `O(1)` |
|  | 최악 | `O(n)` |
| 트리(Tree, 균형 트리) | 탐색/삽입/삭제 | `O(log n)` |
| 그래프(Graph) | DFS/BFS | `O(V + E)` |
| 선형탐색 | Linear Search | `O(n)` |
| 이진탐색 | Binary Search | `O(log n)` |
| 브루트포스 | Brute Force | `O(n!) ~ O(2^n)` |
| 백트래킹 | Backtracking | `≤ O(2^n)` |  
| 비트마스크 | Bitmask | `O(2^n)` |
| 정렬 - 버블 | Bubble Sort | `O(n^2)` |
| 정렬 - 선택 | Selection Sort | `O(n^2)` |
| 정렬 - 삽입 | Insertion Sort | `O(n^2)` |
| 정렬 - 병합 | Merge Sort | `O(n log n)` |
| 정렬 - 퀵 | Quick Sort | 평균 `O(n log n)` / 최악 `O(n^2)` |
| 정렬 - 힙 | Heap Sort | `O(n log n)` |
| 분할정복 | Divide & Conquer | `O(n log n)` (대표적) |
| 동적계획법 | Dynamic Programming | `O(n)` ~ `O(n^2)` |
| 그리디 | Greedy | 문제에 따라 다름 |