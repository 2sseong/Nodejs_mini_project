import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/AuthContext.jsx';
import UserSearch from '../components/User/UserSearch.jsx';
import UserList from '../components/User/UserList.jsx';
import { useChatSocket } from '../hooks/useChatSocket.js';
import { searchAllUsers, toggleUserPick } from '../api/usersApi.jsx';
import { apiFindOrCreateDM } from '../api/roomApi.jsx';
import '../styles/UserPage.css';


export default function UserPage() {
    // 1. 유저 목록 상태 관리
    const [userList, setUserList] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const { userId, userNickname, username } = useAuth();
    const [filterType, setFilterType] = useState('ALL'); // 'ALL' | 'ONLINE' | '⭐'

    // 소켓 훅에서 온라인 사용자 목록 가져오기
    const { onlineUsers } = useChatSocket({ userId, userNickname });

    // 사용자 ID 상태 - 동적관리
    const [myUserId, setMyUserId] = useState(null);
    // 2. 검색어 상태 (UserSearch에서 전달받을 값)
    const [searchQuery, setSearchQuery] = useState('');

    const navigate = useNavigate();

    // 컴포넌트 마운트 시 로컬 스토리지에서 최신 userId를 로드
    useEffect(() => {
        const storedUserId = localStorage.getItem('userId');
        if (storedUserId) {
            setMyUserId(storedUserId);
        } else {
            // ID가 없으면 로딩을 끝내고 에러 표시
            setIsLoading(false);
            setError("사용자 ID를 찾을 수 없습니다. 로그인 상태를 확인하세요.");
        }
    }, []); // 최초 마운트 시점에만 실행

    // 3. UserSearch에서 폼 제출 시 호출될 핸들러 함수
    const handleQueryChange = (query) => {
        // 입력이 들어올 때마다 searchQuery 상태 업뎃
        setSearchQuery(query.trim());
    };

    // 즐겨찾기 토글 처리를 위한 핸들러 함수
    const handleTogglePick = async (targetUserId, isPick) => {
        // isPick 상태는 현재 상태이므로, API에는 반대 액션(추가/제거)을 전달해야 함
        // isAdding: true면 추가 (현재 isPick이 false), false면 제거 (현재 isPick이 true)
        const isAdding = !isPick;

        try {
            // 1. API 호출: 백엔드에 즐겨찾기 상태 변경 요청
            const result = await toggleUserPick(targetUserId, isAdding);

            if (result.success) {
                // 2. [로컬 상태 업데이트]: API 성공 후 userList 상태를 즉시 업데이트
                // 사용자 목록을 순회하며 targetUserId와 일치하는 사용자의 isPick 상태만 반전시킴
                setUserList(prevUsers =>
                    prevUsers.map(user =>
                        user.userId === targetUserId
                            ? { ...user, isPick: isAdding ? 1 : 0 } // isPick 상태 반전
                            : user
                    )
                );
                // 성공 메시지 처리
                console.log(result.message);

            } else {
                // API 실패 메시지 처리
                console.error("즐겨찾기 토글 실패:", result.message);
                // [참고]: alert() 대신 Toast나 Modal UI를 사용하는 것이 좋음(보류)
                alert(`작업 실패: ${result.message}`);
            }

        } catch (err) {
            console.error("API 통신 중 오류 발생:", err);
            alert(`오류가 발생했습니다: ${err.message}`);
        }
    };

    // 채팅 시작 핸들러
    const handleStartChat = async (targetUserId, targetUserNickname) => {
        try {
            let finalRoomId;
            let finalIsNew;

            // 1. 기존 방이 있는지 확인
            let result = await apiFindOrCreateDM(targetUserId, targetUserNickname);

            if (result.isNew) {
                // 2. 새 방이 필요한 경우: 사용자에게 방 이름 입력받기
                const newRoomName = prompt(`새 채팅방 이름을 입력해주세요: (상대방: ${targetUserNickname})`);

                if (!newRoomName || newRoomName.trim() === '') {
                    alert('채팅방 이름을 입력해주세요');
                    return;
                }

                // 3. 입력받은 이름으로 다시 API 호출
                const creationResult = await apiFindOrCreateDM(targetUserId, targetUserNickname, newRoomName);
                finalRoomId = creationResult.roomId;
                finalIsNew = true;
            } else {
                // 4. 기존 방이 있는 경우
                finalRoomId = result.roomId;
                finalIsNew = false;
            }

            const chatPath = `/chat?roomId=${finalRoomId}`;

            // 5. 채팅방으로 이동
            if (finalIsNew) {
                const newWindow = window.open(chatPath, `chatRoom_${finalRoomId}`, 'width=400,height=600,scrollbars=no,resizable=yes');
                if (newWindow) {
                    newWindow.focus();
                    console.log('New DM room created:', finalRoomId);
                } else {
                    alert('팝업 차단이 설정되어 있습니다. 현재 창에서 채팅방으로 이동합니다');
                    navigate(chatPath);
                }
            } else {
                navigate(chatPath);
                console.log('Existing DM room found:', finalRoomId);
            }
        } catch (error) {
            console.error('Failed to start chat:', error);
            alert('채팅방을 열 수 없습니다.');
        }
    };

    // 4. 데이터 페칭 + 정렬 (검색어 변경 시마다 실행)
    useEffect(() => {
        <div className="friend-page">
            <div className="friend-page-header">
                <h1 className="page-title">사용자 관리</h1>
                <p className="page-subtitle">사용자를 검색하고 목록을 관리하세요</p>
            </div>

            <div className="friend-page-content">

                <section className="friend-section list-section">
                    <div className="section-header">
                        <div className="section-icon">👥</div>
                        <h2 className="section-title">
                            {searchQuery ? `검색 결과 (${userList.length}건)` : '사용자 목록'}
                        </h2>
                    </div>
                    <div className="filter-buttons">
                        <button
                            className={filterType === 'ALL' ? 'active' : ''}
                            onClick={() => setFilterType('ALL')}
                        >
                            전체
                        </button>

                        <button
                            className={filterType === 'ONLINE' ? 'active' : ''}
                            onClick={() => setFilterType('ONLINE')}
                        >
                            접속중
                        </button>

                        <button
                            className={filterType === 'PICK' ? 'active' : ''}
                            onClick={() => setFilterType('PICK')}
                        >
                            ⭐
                        </button>
                    </div>
                    <div className="section-content">
                        {/* UserSearch 컴포넌트를 이 섹션 안으로 이동 */}
                        <UserSearch
                            onQueryChange={handleQueryChange}
                        />
                        {listContent} {/* 전체 목록/검색 결과 표시 */}
                    </div>
                </section>
            </div>
        </div>
    );
}
